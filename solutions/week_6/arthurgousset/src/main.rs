use num_bigint::BigInt;
use num_traits::{Zero, One};
use rand::Rng;

/// Returns an integer equivalent in the finite field F_101 (i.e., between 0 and 100)
fn mod_prime(x: &BigInt, modulus: &BigInt) -> BigInt {
    let result = x.modpow(&BigInt::one(), modulus);
    
    // Ensure the result is positive
    if result < BigInt::zero() {
        &result + modulus
    } else {
        result
    }
}

/// Calculates the modular inverse of `a` mod `p` using Fermat's Little Theorem
fn mod_inverse(a: &BigInt, p: &BigInt) -> BigInt {
    // a^(p-2) mod p
    let exp = p - 2;
    a.modpow(&exp, p)
}

#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: BigInt,
    y: BigInt,
}

impl Point {
    /// Creates a new point from x and y coordinates
    fn new(x: BigInt, y: BigInt) -> Self {
        Point { x, y }
    }

    /// Doubles a point on the elliptic curve
    fn double(&self) -> Self {
        let prime = BigInt::from(101);

        // Compute the slope `m` as (3 * x^2) / (2 * y) in F_101
        let three = BigInt::from(3);
        let two = BigInt::from(2);
        let numerator = &three * &self.x * &self.x;
        let denominator = &two * &self.y;
        let denominator_inv = mod_inverse(&denominator, &prime);
        let m = mod_prime(&(&numerator * &denominator_inv), &prime);

        // Calculate the new x and y coordinates using modular arithmetic
        let new_x = mod_prime(&(&m * &m - &two * &self.x), &prime);
        let new_y = mod_prime(&(&m * (&self.x - &new_x) - &self.y), &prime);

        Point { x: new_x, y: new_y }
    }

    /// Adds two points on the elliptic curve
    fn add(&self, other: &Point) -> Self {
        if self == other {
            return self.double();
        }

        let prime = BigInt::from(101);
        let numerator = &other.y - &self.y;
        let denominator = &other.x - &self.x;
        let denominator_inv = mod_inverse(&denominator, &prime);

        let m = mod_prime(&(&numerator * &denominator_inv), &prime);

        let new_x = mod_prime(&(&m * &m - &self.x - &other.x), &prime);
        let new_y = mod_prime(&(&m * (&self.x - &new_x) - &self.y), &prime);

        Point { x: new_x, y: new_y }
    }

    fn scale(&self, scalar: &BigInt) -> Self {
        let mut result = self.clone();
        let one = BigInt::one();
        let mut current = one.clone();

        while &current < scalar {
            result = result.add(self);
            current += &one;
        }

        result
    }

    /// Inverts a point on the elliptic curve
    fn invert(&self) -> Self {
        Point {
            x: self.x.clone(),
            y: mod_prime(&-&self.y, &BigInt::from(101)),
        }
    }
}

fn main() {
    // Initialize G1 generator in F_101
    let g1 = Point::new(BigInt::from(1), BigInt::from(2));
    println!("G1: {:?}", g1);
    
    // Initialize G2 generator in extension field F_{101^2}
    let g2 = Point::new(BigInt::from(1), BigInt::from(2));
    println!("G2: {:?}", g2);
    
    // Test point doubling
    let doubled = g1.double();
    println!("Doubled: {:?}", doubled);
    
    // Test point inversion
    let inverted = g1.invert();
    println!("Inverted: {:?}", inverted);

    // Test point addition
    let p1 = g1.clone();
    let added = p1.add(&doubled);
    println!("Added (G1 + 2G1): {:?}", added);

    // Test point scalar multiplication
    println!("Scaled G1 by 2: {:?}", g1.clone().scale(&BigInt::from(2)));
    println!("Scaled G1 by 3: {:?}", g1.clone().scale(&BigInt::from(3)));

    // Compute subgroup generated by G1
    let mut current = g1.clone();
    println!("{:?}: {:?}", 1, current);
    for i in 2..=16 {
        current = current.add(&g1);
        println!("{:?}: {:?}", i, current);
    }

    // Generate random s < order of group (= 17)
    let s = BigInt::from(2); // Simplification to follow Plonk by Hand tutorial

    // Initialize structure reference string
    let mut srs: Vec<Point> = Vec::new();

    let nr_gates = 4;
    let nr_SRS_elements = nr_gates + 5;
    let subgroup_order = BigInt::from(17);

    // $1 \times G_1$
    srs.push(g1.clone());

    // $S \times G_1$, $S^2 \times G_1$, $S^3 \times G_1$, $S^4 \times G_1$, $S^5 \times G_1$, $S^6 \times G_1$
    for i in 1..=nr_gates+2 {
        let s_power = s.modpow(&BigInt::from(i), &subgroup_order);
        let g1_times_s_power = g1.clone().scale(&s_power);
        println!("S to the power of {:?} is {:?}: {:?}", i, s_power, g1_times_s_power);
        srs.push(g1_times_s_power);
    }

    println!("SRS: {:?}", srs);
}
